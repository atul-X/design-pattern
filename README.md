# Design Patterns Implementation in Java

This project demonstrates the implementation of **5 fundamental design patterns** in Java, showcasing both the problems they solve and their practical applications. Each pattern includes comparison implementations to highlight the benefits of using design patterns.

## üìÅ Project Structure

```
src/
‚îú‚îÄ‚îÄ command/           # Command Pattern Implementation
‚îú‚îÄ‚îÄ memento/           # Memento Pattern Implementation
‚îú‚îÄ‚îÄ observer/          # Observer Pattern Implementation  
‚îú‚îÄ‚îÄ strategy/          # Strategy Pattern Implementation
‚îî‚îÄ‚îÄ template/          # Template Method Pattern Implementation
```

## üéØ Design Patterns Implemented

### 1. Command Pattern üéÆ

**Location:** `src/command/`

**Purpose:** Encapsulates a request as an object, allowing you to parameterize clients with different requests, queue operations, and support undo functionality.

#### Key Components:
- **Command Interface:** `Command.java` - Defines the execute() method
- **Concrete Commands:** `BoldCommand`, `ItalicCommand`, `UnderlineCommand`, `ChangeColorCommand`
- **Receiver:** `TextEditorII` - Performs the actual work
- **Invoker:** `Button` - Triggers command execution

#### Real-World Use Cases:
- **GUI Applications:** Button clicks, menu selections
- **Remote Controls:** TV, AC, Smart Home devices
- **Macro Recording:** Recording and replaying user actions
- **Undo/Redo Operations:** Text editors, image editors
- **Queuing Systems:** Job scheduling, task management

#### Example Usage:
```java
TextEditorII textEditor = new TextEditorII();
Button button = new Button();

// Set different commands dynamically
button.setCommand(new BoldCommand(textEditor));
button.click(); // Executes bold operation

button.setCommand(new ItalicCommand(textEditor));
button.click(); // Executes italic operation
```

#### Benefits Demonstrated:
- **Decoupling:** Invoker doesn't need to know about receiver implementation
- **Flexibility:** Commands can be changed at runtime
- **Extensibility:** Easy to add new commands without modifying existing code

---

### 2. Memento Pattern üíæ

**Location:** `src/memento/`

**Purpose:** Captures and externalizes an object's internal state without violating encapsulation, allowing the object to be restored to this state later.

#### Three Implementations:

#### A. Text Editor with Undo (`texteditor/`)
- **Originator:** `TextEditor` - Creates and restores mementos
- **Memento:** `EditorMemento` - Stores editor state
- **Caretaker:** `CareTaker` - Manages memento history

#### B. Graphic Editor with Shape History (`graphiceditor/`)
- **Originator:** `GraphicEditor` - Manages shape properties (type, position, color, size)
- **Memento:** `EditorMemento` - Stores complete shape state
- **Caretaker:** `Caretaker` - Manages shape history for undo operations
- **Application:** `GraphicEditorApplication` - Interactive demo with user input

#### C. Transaction Rollback System (`tnxrollback/`)
- **Database-like Operations:** Save, update, delete with rollback capability
- **Transaction Management:** Begin, commit, rollback operations

#### Real-World Use Cases:
- **Text Editors:** Undo/Redo functionality (MS Word, VS Code)
- **Graphic Design Software:** Shape manipulation history (Adobe Illustrator, Figma)
- **Database Systems:** Transaction rollback, savepoints
- **Game Development:** Save/load game states, checkpoints
- **Version Control:** Git commits, branching
- **Configuration Management:** System restore points

#### Example Usage:
```java
// Text Editor Example
TextEditor editor = new TextEditor();
CareTaker careTaker = new CareTaker();

editor.write("Hello World");
careTaker.saveState(editor);  // Save current state

editor.write("Modified Text");
careTaker.undo(editor);       // Restore to "Hello World"

// Graphic Editor Example
GraphicEditor graphicEditor = new GraphicEditor();
Caretaker caretaker = new CareTaker();

graphicEditor.setShape("circle", 10, 20, "red", 5);
caretaker.saveState(graphicEditor);  // Save shape state

graphicEditor.setShape("rectangle", 30, 40, "blue", 10);
caretaker.undo(graphicEditor);       // Restore to circle
```

---

### 3. Observer Pattern üëÅÔ∏è

**Location:** `src/observer/weather/`

**Purpose:** Defines a one-to-many dependency between objects so that when one object changes state, all dependents are notified automatically.

#### Key Components:
- **Subject Interface:** `Subject` - Attach, detach, notify observers
- **Observer Interface:** `Observer` - Update method for notifications
- **Concrete Subject:** `Weather` - Maintains state and observer list
- **Concrete Observers:** `DisplayDevices`, `MobileDevice` - React to state changes

#### Real-World Use Cases:
- **GUI Applications:** Model-View architectures (MVC, MVP, MVVM)
- **Event Systems:** DOM events, custom event handlers
- **Stock Market:** Price change notifications to multiple displays
- **Social Media:** Notification systems for followers
- **IoT Systems:** Sensor data broadcasting to multiple devices
- **News Feeds:** Publishing updates to subscribers

#### Example Usage:
```java
Weather weather = new Weather();
DisplayDevices lcd = new DisplayDevices("Samsung LCD");
MobileDevice phone = new MobileDevice("iPhone");

weather.attach(lcd);
weather.attach(phone);

weather.setTemperature(25.5f); // Both devices get notified
```

#### Benefits:
- **Loose Coupling:** Subject and observers are loosely coupled
- **Dynamic Relationships:** Observers can be added/removed at runtime
- **Broadcast Communication:** One-to-many communication

---

### 4. Strategy Pattern üéØ

**Location:** `src/strategy/payment/`

**Purpose:** Defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime.

#### Key Components:
- **Strategy Interface:** `PaymentStrategy` - Common interface for all algorithms
- **Concrete Strategies:** `CreditCard`, `DebitCard` - Different payment methods
- **Context:** `PaymentService` - Uses strategy to perform operations

#### Real-World Use Cases:
- **Payment Processing:** Credit card, PayPal, cryptocurrency, bank transfer
- **Sorting Algorithms:** QuickSort, MergeSort, BubbleSort selection
- **Compression:** ZIP, RAR, 7Z different compression algorithms
- **Navigation Apps:** Fastest route, shortest route, scenic route
- **Pricing Strategies:** Regular, premium, discount pricing
- **Authentication:** OAuth, LDAP, database authentication

#### Example Usage:
```java
PaymentService paymentService = new PaymentService();

// Use credit card payment
paymentService.setPaymentStrategy(new CreditCard());
paymentService.pay();

// Switch to debit card payment
paymentService.setPaymentStrategy(new DebitCard());
paymentService.pay();
```

#### Benefits:
- **Runtime Algorithm Selection:** Choose algorithm dynamically
- **Easy Extension:** Add new strategies without modifying existing code
- **Eliminates Conditionals:** Replaces large if-else or switch statements

---

### 5. Template Method Pattern üìã

**Location:** `src/template/`

**Purpose:** Defines the skeleton of an algorithm in a base class, letting subclasses override specific steps without changing the algorithm's structure.

#### Key Components:
- **Abstract Class:** `DataParser` - Defines template method and common steps
- **Template Method:** `parse()` - Defines algorithm skeleton
- **Concrete Classes:** `CSVParserII`, `JSONParserII` - Implement specific steps

#### Algorithm Steps:
1. **openFile()** - Common implementation
2. **parseData()** - Abstract method (varies by file type)
3. **closeFile()** - Common implementation

#### Real-World Use Cases:
- **Data Processing:** File parsing (CSV, JSON, XML, Excel)
- **Web Frameworks:** Request processing pipeline (authentication, validation, response)
- **Game Development:** Game loop (input, update, render)
- **Testing Frameworks:** Test execution (setup, execute, teardown)
- **Build Systems:** Compilation process (compile, link, package)
- **Report Generation:** Different report formats with common structure

#### Example Usage:
```java
DataParser csvParser = new CSVParserII();
csvParser.parse(); // Uses template method

DataParser jsonParser = new JSONParserII();
jsonParser.parse(); // Same structure, different parsing logic
```

#### Benefits:
- **Code Reuse:** Common algorithm structure shared
- **Controlled Extension:** Subclasses can only override specific steps
- **Consistency:** Ensures algorithm structure remains consistent

---

## üöÄ How to Run

### Prerequisites
- Java 8 or higher
- IDE (IntelliJ IDEA, Eclipse, VS Code)

### Running Examples

Each pattern has its own main class for demonstration:

```bash
# Command Pattern
java command.WithCommondPattern

# Memento Pattern
java memento.texteditor.TextEditorMain
java memento.graphiceditor.GraphicEditorMain
java memento.tnxrollback.Solution

# Observer Pattern
java observer.weather.ObserverPatternExample

# Strategy Pattern
java strategy.payment.StrategyPattern

# Template Method Pattern
java template.WithTemplatePattern
```

#### Interactive Examples:

**Graphic Editor Memento Demo:**
```bash
java memento.graphiceditor.GraphicEditorMain
# Input format: shapeType x y color size
# Example inputs:
# circle 10 20 red 5
# rectangle 30 40 blue 10  
# triangle 50 60 green 15
# The program will undo the last shape and show the restored state
```

## üîç Pattern Comparison

Each pattern includes "WithoutPattern" examples showing:
- **Problems** without using the pattern
- **Code duplication** and tight coupling issues
- **Maintenance difficulties** in traditional approaches

## üõ†Ô∏è Key Benefits of Design Patterns

1. **Reusability:** Proven solutions to common problems
2. **Maintainability:** Easier to modify and extend code
3. **Communication:** Common vocabulary for developers
4. **Best Practices:** Industry-standard approaches
5. **Flexibility:** Adaptable to changing requirements

## üìö Learning Path

1. **Start with Strategy Pattern** - Easiest to understand
2. **Move to Observer Pattern** - Common in GUI applications
3. **Learn Command Pattern** - Powerful for undo/redo systems
4. **Study Template Method** - Great for framework design
5. **Master Memento Pattern** - Essential for state management

## üéì When to Use Each Pattern

| Pattern | Use When | Avoid When |
|---------|----------|------------|
| **Command** | Need undo/redo, queuing, logging | Simple direct method calls suffice |
| **Memento** | Need state restoration, checkpoints | Memory constraints, simple state |
| **Observer** | One-to-many notifications needed | Few observers, tight coupling acceptable |
| **Strategy** | Multiple algorithms for same task | Only one algorithm, no runtime switching |
| **Template Method** | Common algorithm structure with variations | Completely different algorithms |

## üîß Extension Ideas

- Add **Undo functionality** to Command Pattern
- Implement **Composite Pattern** for hierarchical structures
- Add **Factory Pattern** for object creation
- Implement **Decorator Pattern** for feature enhancement
- Create **Facade Pattern** for simplified interfaces

## üìñ Additional Resources

- [Design Patterns: Elements of Reusable Object-Oriented Software](https://en.wikipedia.org/wiki/Design_Patterns) - Gang of Four
- [Head First Design Patterns](https://www.oreilly.com/library/view/head-first-design/0596007124/)
- [Refactoring Guru - Design Patterns](https://refactoring.guru/design-patterns)

---

**Happy Coding! üöÄ**

*This project demonstrates practical implementations of design patterns that you'll encounter in real-world software development.*

## üìä UML Class Diagrams

### 1. Command Pattern UML

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   <<interface>>  ‚îÇ
‚îÇ     Command     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + execute()     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚ñ≥
         ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ         ‚îÇ            ‚îÇ              ‚îÇ                 ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇBoldCmd‚îÇ ‚îÇItalicCmd‚îÇ ‚îÇUnderlineCmd‚îÇ ‚îÇChangeColorCmd    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ-editor‚îÇ ‚îÇ-editor  ‚îÇ ‚îÇ-editor     ‚îÇ ‚îÇ-editor           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ+exec()‚îÇ ‚îÇ+exec()  ‚îÇ ‚îÇ+exec()     ‚îÇ ‚îÇ+exec()           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚îÇ          ‚îÇ            ‚îÇ             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ            ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         ‚îÇ    TextEditorII        ‚îÇ
         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
         ‚îÇ + boldText()           ‚îÇ
         ‚îÇ + italicizeText()      ‚îÇ
         ‚îÇ + underlineText()      ‚îÇ
         ‚îÇ + changeColor()        ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Button      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ   <<interface>> ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îÇ     Command     ‚îÇ
‚îÇ - command       ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + setCommand()  ‚îÇ
‚îÇ + click()       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. Memento Pattern UML

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    TextEditor       ‚îÇ    ‚îÇ   EditorMemento     ‚îÇ    ‚îÇ     CareTaker       ‚îÇ
‚îÇ   (Originator)      ‚îÇ    ‚îÇ    (Memento)        ‚îÇ    ‚îÇ   (Caretaker)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - content: String   ‚îÇ    ‚îÇ - content: String   ‚îÇ    ‚îÇ - history: Stack    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + write(content)    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ + getContent()      ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ + saveState()       ‚îÇ
‚îÇ + save(): Memento   ‚îÇ    ‚îÇ                     ‚îÇ    ‚îÇ + undo()            ‚îÇ
‚îÇ + restore(memento)  ‚îÇ    ‚îÇ                     ‚îÇ    ‚îÇ                     ‚îÇ
‚îÇ + getContent()      ‚îÇ    ‚îÇ                     ‚îÇ    ‚îÇ                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   GraphicEditor     ‚îÇ    ‚îÇGraphicEditorMemento ‚îÇ
‚îÇ   (Originator)      ‚îÇ    ‚îÇ    (Memento)        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - shapeType: String ‚îÇ    ‚îÇ - shapeType: String ‚îÇ
‚îÇ - x: int            ‚îÇ    ‚îÇ - x: int            ‚îÇ
‚îÇ - y: int            ‚îÇ    ‚îÇ - y: int            ‚îÇ
‚îÇ - color: String     ‚îÇ    ‚îÇ - color: String     ‚îÇ
‚îÇ - size: int         ‚îÇ    ‚îÇ - size: int         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + setShape()        ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ + getShapeType()    ‚îÇ
‚îÇ + save(): Memento   ‚îÇ    ‚îÇ + getX()            ‚îÇ
‚îÇ + restore(memento)  ‚îÇ    ‚îÇ + getY()            ‚îÇ
‚îÇ + getShape()        ‚îÇ    ‚îÇ + getColor()        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ + getSize()         ‚îÇ
                           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 3. Observer Pattern UML

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   <<interface>>     ‚îÇ                    ‚îÇ   <<interface>>     ‚îÇ
‚îÇ      Subject        ‚îÇ                    ‚îÇ     Observer        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + attach(observer)  ‚îÇ                    ‚îÇ + update(temp)      ‚îÇ
‚îÇ + detach(observer)  ‚îÇ                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ + notifyObservers() ‚îÇ                             ‚ñ≥
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                             ‚îÇ
         ‚ñ≥                                          ‚îÇ
         ‚îÇ                               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                     ‚îÇ                   ‚îÇ
‚îÇ     Weather      ‚îÇ                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                ‚îÇDisplay  ‚îÇ      ‚îÇMobile      ‚îÇ
‚îÇ - temperature    ‚îÇ                ‚îÇDevices  ‚îÇ      ‚îÇDevice      ‚îÇ
‚îÇ - observers[]    ‚îÇ                ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§                ‚îÇ - name  ‚îÇ      ‚îÇ - name     ‚îÇ
‚îÇ + attach()       ‚îÇ‚óÜ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + detach()       ‚îÇ                ‚îÇ + update‚îÇ      ‚îÇ + update() ‚îÇ
‚îÇ + notify()       ‚îÇ                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ + setTemp()      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 4. Strategy Pattern UML

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PaymentService     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ ‚îÇ   <<interface>>     ‚îÇ
‚îÇ    (Context)        ‚îÇ      ‚îÇ  PaymentStrategy    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ - strategy          ‚îÇ      ‚îÇ + processPayment()  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ + setStrategy()     ‚îÇ               ‚ñ≥
‚îÇ + pay()             ‚îÇ               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                             ‚îÇ                 ‚îÇ
                      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                      ‚îÇ CreditCard  ‚îÇ   ‚îÇ DebitCard  ‚îÇ
                      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                      ‚îÇ + process() ‚îÇ   ‚îÇ + process()‚îÇ
                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 5. Template Method Pattern UML

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    <<abstract>>         ‚îÇ
‚îÇ      DataParser         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ + parse() {final}       ‚îÇ  ‚Üê Template Method
‚îÇ # openFile()            ‚îÇ
‚îÇ # closeFile()           ‚îÇ
‚îÇ # parseData() {abstract}‚îÇ  ‚Üê Hook Method
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚ñ≥
            ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ               ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇCSVParser‚îÇ    ‚îÇJSONParser‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ+parse  ‚îÇ    ‚îÇ+parseData‚îÇ
‚îÇData()  ‚îÇ    ‚îÇ()        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Algorithm Flow:
1. openFile()    ‚Üê Common
2. parseData()   ‚Üê Varies by subclass  
3. closeFile()   ‚Üê Common
```

### 6. UML Relationship Legend

```
Relationships:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Association (uses)
‚óÜ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ Composition (has-a, strong)
‚óá‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂ Aggregation (has-a, weak)  
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≥  Inheritance (is-a)
- - -‚ñ≥  Implementation (realizes)
